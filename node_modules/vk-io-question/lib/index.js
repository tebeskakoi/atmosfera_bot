'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

class Answer {
    constructor({ text, forwards, payload, attachments, duration, isTimeout }) {
        /**
         * Является ли данный ответ, неотвеченным вовремя
         */
        this.isTimeout = false;
        this.text = text;
        this.forwards = forwards;
        this.payload = payload;
        this.attachments = attachments;
        this.duration = duration;
        this.createdAt = Date.now();
        this.isTimeout = isTimeout ?? false;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
}

class QuestionManager {
    constructor(params) {
        this.questions = new Map();
        this.timeouts = new Map();
        this.answerTimeLimit = 0;
        this.answerTimeLimit = params?.answerTimeLimit || 0;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Middleware-функция - является основным функционалом.
     */
    get middleware() {
        return async (context, next) => {
            if (!context.is(['message'])) {
                await next();
                return;
            }
            const currentQuestion = this.questions.get(context.senderId);
            if (currentQuestion) {
                currentQuestion.resolve(new Answer({
                    text: context.text || null,
                    forwards: context.forwards,
                    payload: context.messagePayload,
                    attachments: context.attachments,
                    duration: Date.now() - currentQuestion.startTime
                }));
                return this.questions.delete(context.senderId);
            }
            /**
             * @param message  Отправляемое сообщение (вопрос)
             * @param params Параметры сообщения
             */
            context.question = async (message, params = {}) => {
                if (!message) {
                    throw new TypeError('Parameter `message` is required');
                }
                await context.send(message, params);
                return new Promise((resolve) => {
                    const userId = params?.targetUserId ?? context.senderId;
                    this.questions.set(userId, {
                        resolve,
                        startTime: Date.now()
                    });
                    const answerTimeLimit = params.answerTimeLimit ?? this.answerTimeLimit;
                    const currentTimeout = this.timeouts.get(context.senderId);
                    if (currentTimeout)
                        clearTimeout(currentTimeout);
                    if (answerTimeLimit > 0) {
                        this.timeouts.set(context.senderId, setTimeout(() => {
                            const currentQuestion = this.questions.get(context.senderId);
                            if (currentQuestion) {
                                resolve(new Answer({
                                    text: null,
                                    forwards: null,
                                    payload: null,
                                    attachments: null,
                                    duration: Date.now() - currentQuestion.startTime,
                                    isTimeout: true
                                }));
                                return this.questions.delete(context.senderId);
                            }
                            this.timeouts.delete(context.senderId);
                        }, answerTimeLimit));
                    }
                });
            };
            await next();
        };
    }
}

exports.Answer = Answer;
exports.QuestionManager = QuestionManager;
exports.default = QuestionManager;
